
Todo:
    + Refactor the core engine methods to be part of the Board struct instead of Position.
    + Add auto-scoring functionality
    + Make it auto-save every 10 seconds (or on every action or something).
        - Currently it doesn't save if you exit with ctrl-C, which is obviously bad.

    + Make it mark illegal moves (i.e. ko violations) somehow.
    + Add "competitive mode" where it doesn't mark immortal stones
    + Make it be possible to see which moves have been made from a given position
      (maybe by holding down ctrl)
    + Make it possible to play on a board without saving it


- Investigate what's making turn-taking on the 39x39 board so slow.
    - It's the seed_chain() method, called when removing non-immortal chains.
      It takes a noticeable amount of time to run once on this board and that
      method calls it a lot.


Old, maybe faster algorithm for updating the chains after adding a newly-placed stone to the board:

        // Create a sorted, de-dupped list of all the ID's of the same-colored
        // chains this move was adjacent to (there can be zero or more of these).

        //let mut adjacent_chain_ids: Vec<usize> =
            //self.board.neighbor_lists[point].iter()
                //.filter(|&&n| self.board_state[n] == color)
                //.map(|&n| self.chain_id_backref[n])
                //.collect();

        //adjacent_chain_ids.sort();
        //adjacent_chain_ids.dedup();

        // If there were no chains adjacent to this move, get a fresh chain ID
        // and consider the move "adjacent" to that chain.

        //let dest_chain = match adjacent_chain_ids.len() {
            //0 => self.fresh_chain_id(color),
            //_ => adjacent_chain_ids.swap_remove(0),
        //};

        // Put this stone on the board; push it onto the destination chain.

        //self.board_state[point] = color;
        //self.chains[color as usize][dest_chain].push(point);

        // Drain all the other chains in the list into the first one.

        //let mut temp = Vec::<usize>::new();

        //for chain_id in adjacent_chain_ids {
            //temp.append(&mut self.chains[color as usize][chain_id]);
            //self.chains[color as usize][dest_chain].append(&mut temp);
        //}

        // ...and update the backref for all points in this chain.

        //for point in &self.chains[color as usize][dest_chain] { 
            //self.chain_id_backref[*point] = dest_chain;
        //}

